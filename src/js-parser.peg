{
  var none,
  entities = {},
  entity = Entity();

  function Entity(){
    return {
      description: '',
      short_description: ''
    };
  }

  function indent_shift(source){
    var min_indent = -1;
    /* calculate minimum number of initial spaces */
    source.replace(/(?:^|\n)([\ \t]*)([^\n])/g, function(_, indent){
      min_indent = min_indent < 0 ? indent.length : Math.min(min_indent, indent.length);
    });
    /* remove redundant initial spaces */
    return source.replace(new RegExp('(^|\\n)([\\ \\t]{' + min_indent + '})', 'g'), '$1');
  }
}

file
  = chunk* { return entities; }

chunk
  = entity
  / ANY

entity
  = OPEN tags?
    heading
    description (
    CLOSE {
      /* capture line number workaround */
      if(typeof line !== 'undefined'){
        entity.line = line + 1;
      }
    }
  ) {
    entities[entity.id] = entity;
    /* init new supposed entity */
    entity = Entity();
  }

OPEN
  = '/**' _*

CLOSE
  = ( $ _* )? '**/'

tags
  = tag ( _* ',' _* tags )?

tag
  = 'deprecated' ( _* ':' _* since:version _* '..' _* off:version { entity.deprecated = {since: since, off:off}; }
                   / _* ':' _* since:version { entity.deprecated = {since: since}; }
                   / { entity.deprecated = true; } )
  / id:'read-only' {
    entity.readonly = true;
  }
  / id:( 'internal' / 'chainable' ) {
    entity[id] = true;
  }
  / id:( 'section' / 'alias of' / 'related to' / 'belongs to' ) _* ':' _* name:name {
    /* `alias of' -> `alias_of' */
    entity[id.replace(/\ /g, '_')] = name;
  }

heading
  = FEED+ ( signatures
          / class
          / mixin
          / section
          / namespace )
  ( FEED ( includes
         / fires ) )*

description
  = FEED value:( FEED+ TEXT_BLOCK ) {
    entity.description = indent_shift(value[0].pop().replace(/^\n([\ \t]*)/, '$1') + value[1]);
    // short description lasts until the first empty line
    entity.short_description = entity.description.replace(/\n\n[\s\S]*$/, '');
  }
/* Empty description */
  / FEED*

includes
  = 'includes' _+ includes:names {
    entity.included_mixins = includes;
  }

fires
  = 'fires' _+ events:events {
    entity.events = events;
  }

argument_descriptions
  = argument_description ( FEED argument_descriptions )?

argument_description
  = '-' _* name:NAME
  types:( _* '(' _* ntypes:names_alternation _* ')' { return ntypes; } )?
  desc:( _* ':' _* ndesc:argument_description_TEXT_BLOCK { return ndesc; } )? {
    (entity.arguments = entity.arguments || []).push({
      name: name,
      types: types || 'mixed',
      description: desc || ''
    });
  }

argument_description_TEXT_BLOCK
  = !( CLOSE / '-' _* NAME / FEED ) first:TEXT_CHUNK rest:( FEED nested:argument_description_TEXT_BLOCK { return '\n' + nested; } )? {
    return first + rest;
  }

events
  = first:event rest:( ',' nested:events { return nested; } )? {
    rest = rest || [];
    rest.unshift(first);
    return rest;
  }

event
  = first:NAME rest:( sp:( ':' / '.' / '@' / '-' ) id:event { return sp + id; } )? {
    return first + rest;
  }

name_or_namespace
  = first:NAME rest:( '.' nested:name_or_namespace { return nested; } )? {
    return first + (rest ? '.' + rest : '');
  }

name
  = first:name_or_namespace rest:( '@' event
                                   / '#' NAME
                                   / ) {
    return first + rest.join('');
  }

names
  = first:name rest:( _* ',' _* names:names { return names; } )? {
    var names = rest || [];
    names.unshift(first);
    return names;
  }

names_alternation
  = '?' { return []; }
  / name:name rest:( _* '|' _* alts:names_alternation { return alts; } )? {
    var alts = rest || [];
    alts.unshift(name);
    return alts;
  }

VALUE
  = QUOTED_STRING
  / NULL
  / NUMBER
  / BOOLEAN
  / REGEXP
  / ARRAY
  / OBJECT
  / name

ARRAY
  = '[' values:ARRAY_ENTRIES? ellipsis:'...'? ']' {
    value = values || [];
    values.array = true;
    if(ellipsis){
      values.ellipsis = true;
    }
    return values;
  }

ARRAY_ENTRIES
  = first:VALUE rest:( _* ',' _* next:ARRAY_ENTRIES { return next; } )? {
    rest = rest || [];
    rest.unshift(first);
    return rest;
  }

OBJECT
  = '{' values:OBJECT_ENTRIES? '}' {
    return values || {};
  }

OBJECT_ENTRIES
  = key:KEY _* ':' _* value:VALUE rest:( _* ',' _* next:OBJECT_ENTRIES { return next; } )? {
    rest = rest || {};
    rest[key] = value;
    return rest;
  }

KEY
  = QUOTED_STRING
  / NAME

section
  = '==' _* id:name _* '==' {
    entity.id = id;
    entity.type = 'section';
  }

namespace
  = id:name {
    entity.id = id;
    entity.type = 'namespace';
  }

class
  = 'class' _+ id:name superclass:( _* '<' _* nested:name { return nested; } )? {
    entity.id = id;
    entity.type = 'class';
    entity.superclass = superclass || none;
  }

mixin
  = 'mixin' _+ id:name {
    entity.id = id;
    entity.type = 'mixin';
  }

property
  = id:name results {
    entity.id = id;
    entity.type = 'property';
  }

constant
  = id:name _* '=' _* results:result_entries {
    entity.id = id;
    entity.type = 'constant';
    entity.returns = results;
  }

signatures
  = bare_signatures ( FEED argument_descriptions )?

bare_signatures
  = signature ( FEED bare_signatures )?
  {
    entity.signatures = entity.signatures || [];
    entity.signatures.unshift({
      args: entity.args,
      returns: entity.returns
    });
    
    delete entity.args;
    delete entity.returns;
  }

signature
  = method
  / constructor
  / property
  / constant

method
  = method_entry results

constructor
  = 'new' _+ method_entry {
    entity.id = entity.id + '.new';
    entity.type = 'constructor';
  }

method_entry
  = id:name _* '(' _* bound:'@'? _* args:args? _* ')' {
    entity.id = id;
    entity.type = 'method';
    entity.args = args || [];
    if(bound){
      entity.bound = true;
    }
  }

results
  = _* '->' _* results:result_entries {
    entity.results = results;
  }

result_entries
/* anything */
  = '?' {
    return [
      {type: '?'}
    ];
  }
  / first:VALUE rest:( '|' nested:results { return nested; } )? {
    rest = rest || [];
    var ret = {
      type: String(first)
    };
    if(first.array){
      ret.array = true;
    }
    if(first.ellipsis){
      ret.ellipsis = true;
    }
    rest.unshift(ret);
    return rest;
  }

args
  = first:arg? rest:( _* ',' _* args:args { return args; } )? opt:( ( ',' _* )? '[' _* ( ',' _* )? _* args:args _* ']' { return args; } )? {
    rest = rest || [];
    if(first){
      rest.unshift(first);
    }
    if(opt){
      for(var i = 0; i < opt.length; i++){
        opt[i].optional = true;
      }
      rest = rest.concat(opt);
    }
    return rest;
  }

arg
  = name:NAME args:( _* '(' _* a:args _* ')' { return a; } )?
  ext:( _* '=' _* value:VALUE { return {value:value}; } /* with default value */
        / _* '...' { return {ellipsis:true}; } /* with ellipsis */
      )?
  {
    var arg = {
      name: name
    };
    if(args){
      arg.args = args;
    }
    if(none !== ext.value){
      arg.default_value = ext.value;
    }
    if(ext.ellipsis){
      arg.allipsis = true;
    }
    return arg;
  }

version
  = first:[0-9]+ rest:( '.' v:version { return v; } )? {
    return first.join('') + (rest ? '.' + rest : '');
  }

NUMBER
  = int_sign:[-]? int_part:( first:[1-9] rest:[0-9]+ { return first + rest.join(''); } / [0-9] )
    frac_part:( '.' digits:[0-9]+ { return '.' + digits.join(''); } )?
    exp_part:( [eE] sign:[\-\+]? digits:[0-9]+ { return 'e' + ('-' === sign ? sign : '') + digits.join(''); } )?
  { return parseFloat(int_sign + int_part + frac_part + exp_part); }

QUOTED_STRING
/* double quoted strings */
  = [\"] content:( [\\] [\"] { return '\\"'; } / [\\] [\n] { return '\n'; } / [^\"\n] )* [\"] {
    return content.join('');
  }
/* single quoted strings */
  / [\'] content:( [\\] [\'] { return '\\\''; } / [\\] [\n] { return '\n'; } / [^\'\n] )* [\'] {
    return content.join('');
  }

NAME
  = first:[$_a-zA-Z] rest:[$_a-zA-Z0-9]* {
    return first + rest.join('');
  }

REGEXP
  = '/' expression:( '\\/' / [^/] )* '/' flags:[gim]* {
    return new RegExp(expression.join(''), flags.join(''));
  }

BOOLEAN
  = 'true'i { return true; }
  / 'false'i { return false; }

NULL
  = 'null'i { return null; }

TEXT_CHUNK
  = first:[^\r\n] rest:( !FEED TEXT_CHUNK? / &FEED '' ) {
  return first + rest.join('');
}

TEXT_BLOCK
  = !CLOSE first:TEXT_CHUNK rest:( feed:FREE_FEED+ text:TEXT_BLOCK { return feed.join('') + text; } )? {
    return first + rest;
  }

ANY
  = .

FEED
  = $ _* '*' !'*' spacing:_* { return '\n' + spacing.join(''); }

FREE_FEED
  = $ ( _* '*' )? !'*' spacing:_* { return '\n' + spacing.join(''); }

_ /* white space */
  = [\ \t]

$ /* line feed */
  = [\r]? [\n]
